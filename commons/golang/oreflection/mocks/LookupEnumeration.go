// Code generated by mockery v1.0.0
package mocks

import mock "github.com/stretchr/testify/mock"

// LookupEnumeration is an autogenerated mock type for the LookupEnumeration type
type LookupEnumeration struct {
	mock.Mock
}

// ByStringToUint16 provides a mock function with given fields: input
func (_m *LookupEnumeration) ByStringToUint16(input string) (uint16, bool) {
	ret := _m.Called(input)

	var r0 uint16
	if rf, ok := ret.Get(0).(func(string) uint16); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ByStringToUint32 provides a mock function with given fields: input
func (_m *LookupEnumeration) ByStringToUint32(input string) (uint32, bool) {
	ret := _m.Called(input)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(string) uint32); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ByStringToUint8 provides a mock function with given fields: input
func (_m *LookupEnumeration) ByStringToUint8(input string) (uint8, bool) {
	ret := _m.Called(input)

	var r0 uint8
	if rf, ok := ret.Get(0).(func(string) uint8); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ByUint16ToCamelCase provides a mock function with given fields: input
func (_m *LookupEnumeration) ByUint16ToCamelCase(input uint16) (string, bool) {
	ret := _m.Called(input)

	var r0 string
	if rf, ok := ret.Get(0).(func(uint16) string); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(uint16) bool); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ByUint16ToSnakeCase provides a mock function with given fields: input
func (_m *LookupEnumeration) ByUint16ToSnakeCase(input uint16) (string, bool) {
	ret := _m.Called(input)

	var r0 string
	if rf, ok := ret.Get(0).(func(uint16) string); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(uint16) bool); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ByUint32ToCamelCase provides a mock function with given fields: input
func (_m *LookupEnumeration) ByUint32ToCamelCase(input uint32) (string, bool) {
	ret := _m.Called(input)

	var r0 string
	if rf, ok := ret.Get(0).(func(uint32) string); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(uint32) bool); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ByUint32ToSnakeCase provides a mock function with given fields: input
func (_m *LookupEnumeration) ByUint32ToSnakeCase(input uint32) (string, bool) {
	ret := _m.Called(input)

	var r0 string
	if rf, ok := ret.Get(0).(func(uint32) string); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(uint32) bool); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ByUint8ToCamelCase provides a mock function with given fields: input
func (_m *LookupEnumeration) ByUint8ToCamelCase(input uint8) (string, bool) {
	ret := _m.Called(input)

	var r0 string
	if rf, ok := ret.Get(0).(func(uint8) string); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(uint8) bool); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ByUint8ToSnakeCase provides a mock function with given fields: input
func (_m *LookupEnumeration) ByUint8ToSnakeCase(input uint8) (string, bool) {
	ret := _m.Called(input)

	var r0 string
	if rf, ok := ret.Get(0).(func(uint8) string); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(uint8) bool); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}
